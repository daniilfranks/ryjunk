import json
import re
import os
import sys
import requests
import logging
import validictory
import schema
from dataerror import DataError
from genericdb import GenDB
from datetime import datetime
from collections import namedtuple


OK, ERROR = 0, 1

_log = logging.getLogger(' ')

''' Named tuple "class". Work almost as a struct in C.
    see http://rrees.me/2015/04/28/python-preferring-named-tuples-over-classes/
	Type definition of a complex structure'''
Stock = namedtuple('Stock', 'name url value date')

def read_json(file):
	''' Open and read the full content of a json file '''

	assert file is not None, "pre-condition assert"

	try:
		with open(file) as f:
			f = f.read()
			data = json.loads(f)
			#schema = {"type": "object", "properties":{"stocks":{["name":"string"]}}}
			#schema = {"type":"object", "properties":{"array", "minItems":1}}
			schema = {"type":"object"}
			#s = open('schema.json')
			#schema = {"type":"object","properties":{"stocks":{"id":"stocks","type":"array","additionalItems":"false"}},"additionalProperties":"false"}
			schema = {"type":"object","properties":{"stocks":{"type":"array" }}}
			#schema = {"type":"object","properties":{"stocks":{"type":["type":"object"] }}}	
			#schema = {"type":"object","properties":{"stocks":{"id":"stocks","type":"array","items":{"id":"4","type":"object","properties":{"spp global":{"type":"string"}}}}}}		
			#schema = {"type":"object","properties":{"stocks":{"id":"stocks","type":"array","items":{"id":"3","type":"object","properties":{"spp global":{"id":"spp global","type":"string"}}}}}}
			# http://jsonschema.net/#/
			#schema = {"type":"object","properties":{"stocks":{"id":"stocks","type":"array","items":{"id":"auto-generated-schema-594", "type":"object"}}}}
			schema = {"type":"object","properties":{"stocks":{"id":"stocks","type":"array","items":{"type":"object"}}}}

			# http://www.alexconrad.org/2011/10/json-validation.html
			validictory.validate(data, schema)
		return data
	except FileNotFoundError as e:
		raise DataError("Can not load json file: {}".format(e))

	except ValueError as e:
		raise DataError("Wrong format in json file: {}".format(e))

#	 	raise NDataError(message ="Cannot Load json file:{}".format(file),
#	 		             path = '...',
#	 		             line = sys.exc_info()[-1].tb_lineno)

def geturl(k, url=''):
	''' Fetch a request URL'''
	assert k is not None
	assert url is not None

	try:
		sock = requests.get(url)
		html = sock.text
		sock.close()
		return html
	except requests.exceptions.MissingSchema as e:
		raise DataError("Cannot fetch {} requested URL:{}".format(k, url))

def senasteNAV(k='', url=''):
	''' Filter out appropriate data from morningstar URL. 
		Need to be changed if morningstar changes format'''
	
	html = geturl(k, url)
	nav = re.search('Senaste NAV.*\ ([\d]*\,[\d]*)\ SEK[.]*', html)

	if nav is None:
		raise DataError("Cannot find {} NAV in URL:{}".format(k, url))

	''' Pick the digits in the regexp '''	
	return nav.group(1).replace(",",".")

def build_stocks(file):
	''' Based on json file content fetch information, add list of
	funds
	'''
	stocks = []

	data = read_json(file)

	for i, _ in enumerate(range(len(data["stocks"]))):
		stock = data["stocks"][i]
		for k, v in stock.items():
			s = Stock(name=k, value=senasteNAV(k,v), url=v,
					 date=str(datetime.now().strftime('%Y-%m-%d %H:%M:%S')))
		stocks.append(s)
	
	assert stocks, "Valid post-condition?"

	return stocks

def main(args):

	exit_code = ERROR

	try:
		''' Load json file with funds that is interesting. It includes URL to 
		morningstars data about the fund
		'''
		test = build_stocks('./stocks.json')

		''' Iterate over the collected data '''
		# for i in test:
		# 	print (i.name, i.value, i.date)

		''' Put the data in a sqlite database for later diagnostics'''

		arrray = ["name text", "value text", "date text"]
		db = GenDB('mystocks', fields= arrray)

		for i in test:
			db.write([i.name, i.value, i.date])

		exit_code = OK

	# All error/exception handling handled here.
	# Errors generated by user, wrong input, infrastructure problems, net
	# or database errors will be dealt with as DataError. This is raised
	# by this program or catched by this program and reraised as DataError.
	# By default should no line number in program or trace call back be
	# printed only:  e.g.
	# --cannot <perform action> at <location>:<something> is <actual> but 
	# must be <expected>--
	#
	# Programming errors should be handled the ordinary way with line number
	# and trace call back. Asserts will lead to these exceptions
	#	
	except KeyboardInterrupt:
		_log.error('Stopped as requested by user')

	except (DataError, EnvironmentError) as error:
		''' Exceptions casued either input error OR problem with underlaying 
			infrastructure like net or sqlite database Log and exit.
			EnvironmentError embraces IOError, OSError 
		'''
		_log.error(error)

	except Exception as error:
		''' Programming error. Trace callback and line number in output 
		'''
		_log.exception(error)

	except :
		_log.exception("Fundamental problems:{}".format(sys.exc_info()[0]))

	return exit_code


if __name__ == '__main__':
	logging.basicConfig(level=logging.ERROR) # , filename='errors.log')
	sys.exit(main(sys.argv[1:]))


# TODO:
# - parsning: python altstocks -i stock.json
# - Constants for a lot of stuff.
# - Include som test stuff ...
# - Invariants on functions?
# - Mocking functions?
#- Colors when errors?